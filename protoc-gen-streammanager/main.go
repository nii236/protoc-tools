package main

import (
	"flag"
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	// Only generate if there are streaming services
	hasStreamingServices := false
	for _, service := range file.Services {
		for _, method := range service.Methods {
			if method.Desc.IsStreamingServer() {
				hasStreamingServices = true
				break
			}
		}
		if hasStreamingServices {
			break
		}
	}

	if !hasStreamingServices {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_streammanager.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	generateHeader(g, file)
	generateStreamManagerBase(g, file)

	for _, service := range file.Services {
		generateServiceStreamManagers(g, file, service)
	}
}

func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-streammanager. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"fmt"`)
	g.P(`	"sync"`)
	g.P(`	"connectrpc.com/connect"`)
	g.P(")")
	g.P()
}

func generateStreamManagerBase(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("import \"time\"")
	g.P("import \"context\"")
	g.P("import \"crypto/rand\"")
	g.P("import \"encoding/hex\"")
	g.P()
	g.P("// generateSessionID creates a random hex string for session identification")
	g.P("func generateSessionID() string {")
	g.P("	bytes := make([]byte, 16)")
	g.P("	rand.Read(bytes)")
	g.P("	return hex.EncodeToString(bytes)")
	g.P("}")
	g.P()
	g.P("// StreamContext holds metadata for a streaming RPC")
	g.P("type StreamContext[TReq, TResp any] struct {")
	g.P("	SessionID string")
	g.P("	Request   *TReq")
	g.P("	Stream    *connect.ServerStream[TResp]")
	g.P("	Metadata  map[string]string")
	g.P("	StartTime int64")
	g.P("	ctx       context.Context")
	g.P("	cancel    context.CancelFunc")
	g.P("}")
	g.P()
	g.P("// Generic stream manager for any RPC stream type")
	g.P("type StreamManager[TReq, TResp any] struct {")
	g.P("	streams map[string]*StreamContext[TReq, TResp] // sessionID -> context")
	g.P("	mu      sync.RWMutex")
	g.P("}")
	g.P()
	g.P("func NewStreamManager[TReq, TResp any]() *StreamManager[TReq, TResp] {")
	g.P("	return &StreamManager[TReq, TResp]{")
	g.P("		streams: make(map[string]*StreamContext[TReq, TResp]),")
	g.P("	}")
	g.P("}")
	g.P()
	g.P("func (s *StreamManager[TReq, TResp]) AddStream(ctx context.Context, request *TReq, stream *connect.ServerStream[TResp], keyvals ...string) string {")
	g.P("	s.mu.Lock()")
	g.P("	defer s.mu.Unlock()")
	g.P("	")
	g.P("	sessionID := generateSessionID()")
	g.P("	metadata := parseMetadata(keyvals...)")
	g.P("	streamCtx, cancel := context.WithCancel(ctx)")
	g.P("	")
	g.P("	streamContext := &StreamContext[TReq, TResp]{")
	g.P("		SessionID: sessionID,")
	g.P("		Request:   request,")
	g.P("		Stream:    stream,")
	g.P("		Metadata:  metadata,")
	g.P("		StartTime: time.Now().Unix(),")
	g.P("		ctx:       streamCtx,")
	g.P("		cancel:    cancel,")
	g.P("	}")
	g.P("	")
	g.P("	s.streams[sessionID] = streamContext")
	g.P("	")
	g.P("	// Start goroutine to handle context cancellation")
	g.P("	go func() {")
	g.P("		<-streamCtx.Done()")
	g.P("		s.RemoveStream(sessionID)")
	g.P("	}()")
	g.P("	")
	g.P("	return sessionID")
	g.P("}")
	g.P()
	g.P("func (s *StreamManager[TReq, TResp]) SendToStream(sessionID string, response *TResp) error {")
	g.P("	s.mu.RLock()")
	g.P("	ctx, exists := s.streams[sessionID]")
	g.P("	s.mu.RUnlock()")
	g.P("	")
	g.P("	if !exists {")
	g.P(`		return fmt.Errorf("no stream for session %s", sessionID)`)
	g.P("	}")
	g.P("	")
	g.P("	return ctx.Stream.Send(response)")
	g.P("}")
	g.P()
	g.P("func (s *StreamManager[TReq, TResp]) GetContext(sessionID string) (*StreamContext[TReq, TResp], bool) {")
	g.P("	s.mu.RLock()")
	g.P("	defer s.mu.RUnlock()")
	g.P("	ctx, exists := s.streams[sessionID]")
	g.P("	return ctx, exists")
	g.P("}")
	g.P()
	g.P("func (s *StreamManager[TReq, TResp]) RemoveStream(sessionID string) {")
	g.P("	s.mu.Lock()")
	g.P("	defer s.mu.Unlock()")
	g.P("	if ctx, exists := s.streams[sessionID]; exists {")
	g.P("		ctx.cancel()")
	g.P("		delete(s.streams, sessionID)")
	g.P("	}")
	g.P("}")
	g.P()
	g.P("func (s *StreamManager[TReq, TResp]) HasStream(sessionID string) bool {")
	g.P("	s.mu.RLock()")
	g.P("	defer s.mu.RUnlock()")
	g.P("	_, exists := s.streams[sessionID]")
	g.P("	return exists")
	g.P("}")
	g.P()
	g.P("func (s *StreamManager[TReq, TResp]) StreamCount() int {")
	g.P("	s.mu.RLock()")
	g.P("	defer s.mu.RUnlock()")
	g.P("	return len(s.streams)")
	g.P("}")
	g.P()
	g.P("// StreamFilter is a function that determines if a stream should receive a message")
	g.P("type StreamFilter[TReq, TResp any] func(*StreamContext[TReq, TResp]) bool")
	g.P()
	g.P("// parseMetadata converts variadic key-value pairs to a map")
	g.P("func parseMetadata(keyvals ...string) map[string]string {")
	g.P("	if len(keyvals)%2 != 0 {")
	g.P("		panic(\"odd number of key-value pairs\")")
	g.P("	}")
	g.P("	metadata := make(map[string]string)")
	g.P("	for i := 0; i < len(keyvals); i += 2 {")
	g.P("		metadata[keyvals[i]] = keyvals[i+1]")
	g.P("	}")
	g.P("	return metadata")
	g.P("}")
	g.P()
	g.P("// SendToStreamsFiltered sends a response to all streams matching the filter")
	g.P("func (s *StreamManager[TReq, TResp]) SendToStreamsFiltered(response *TResp, filter StreamFilter[TReq, TResp]) ([]string, error) {")
	g.P("	s.mu.RLock()")
	g.P("	contexts := make([]*StreamContext[TReq, TResp], 0)")
	g.P("	for _, ctx := range s.streams {")
	g.P("		if filter == nil || filter(ctx) {")
	g.P("			contexts = append(contexts, ctx)")
	g.P("		}")
	g.P("	}")
	g.P("	s.mu.RUnlock()")
	g.P()
	g.P("	var sentSessionIDs []string")
	g.P("	var lastErr error")
	g.P("	for _, ctx := range contexts {")
	g.P("		if err := ctx.Stream.Send(response); err != nil {")
	g.P("			lastErr = err")
	g.P("		} else {")
	g.P("			sentSessionIDs = append(sentSessionIDs, ctx.SessionID)")
	g.P("		}")
	g.P("	}")
	g.P()
	g.P("	if len(sentSessionIDs) == 0 && lastErr != nil {")
	g.P("		return nil, fmt.Errorf(\"failed to send to any streams: %w\", lastErr)")
	g.P("	}")
	g.P("	return sentSessionIDs, nil")
	g.P("}")
	g.P()
	g.P("// SendToStreamsWithMetadata sends a response to all streams matching a single metadata key-value pair")
	g.P("func (s *StreamManager[TReq, TResp]) SendToStreamsWithMetadata(response *TResp, key, value string) ([]string, error) {")
	g.P("	filter := func(ctx *StreamContext[TReq, TResp]) bool {")
	g.P("		return ctx.Metadata[key] == value")
	g.P("	}")
	g.P("	return s.SendToStreamsFiltered(response, filter)")
	g.P("}")
	g.P()
	g.P("// ListStreams returns all stream contexts matching the filter")
	g.P("func (s *StreamManager[TReq, TResp]) ListStreams(filter StreamFilter[TReq, TResp]) []*StreamContext[TReq, TResp] {")
	g.P("	s.mu.RLock()")
	g.P("	defer s.mu.RUnlock()")
	g.P()
	g.P("	var results []*StreamContext[TReq, TResp]")
	g.P("	for _, ctx := range s.streams {")
	g.P("		if filter == nil || filter(ctx) {")
	g.P("			results = append(results, ctx)")
	g.P("		}")
	g.P("	}")
	g.P("	return results")
	g.P("}")
	g.P()
	g.P("// NoOpStreamManager is a no-op implementation for testing")
	g.P("type NoOpStreamManager[TReq, TResp any] struct {}")
	g.P()
	g.P("func NewNoOpStreamManager[TReq, TResp any]() *NoOpStreamManager[TReq, TResp] {")
	g.P("	return &NoOpStreamManager[TReq, TResp]{}")
	g.P("}")
	g.P()
	g.P("func (n *NoOpStreamManager[TReq, TResp]) AddStream(ctx context.Context, request *TReq, stream *connect.ServerStream[TResp], keyvals ...string) string { return \"noop\" }")
	g.P("func (n *NoOpStreamManager[TReq, TResp]) SendToStream(sessionID string, response *TResp) error { return nil }")
	g.P("func (n *NoOpStreamManager[TReq, TResp]) GetContext(sessionID string) (*StreamContext[TReq, TResp], bool) { return nil, false }")
	g.P("func (n *NoOpStreamManager[TReq, TResp]) RemoveStream(sessionID string) {}")
	g.P("func (n *NoOpStreamManager[TReq, TResp]) HasStream(sessionID string) bool { return false }")
	g.P("func (n *NoOpStreamManager[TReq, TResp]) StreamCount() int { return 0 }")
	g.P("func (n *NoOpStreamManager[TReq, TResp]) SendToStreamsFiltered(response *TResp, filter StreamFilter[TReq, TResp]) ([]string, error) { return nil, nil }")
	g.P("func (n *NoOpStreamManager[TReq, TResp]) SendToStreamsWithMetadata(response *TResp, key, value string) ([]string, error) { return nil, nil }")
	g.P("func (n *NoOpStreamManager[TReq, TResp]) ListStreams(filter StreamFilter[TReq, TResp]) []*StreamContext[TReq, TResp] { return nil }")
	g.P()
	g.P("// DebugStreamManager logs all operations for testing")
	g.P("type DebugStreamManager[TReq, TResp any] struct {}")
	g.P()
	g.P("func NewDebugStreamManager[TReq, TResp any]() *DebugStreamManager[TReq, TResp] {")
	g.P("	return &DebugStreamManager[TReq, TResp]{}")
	g.P("}")
	g.P()
	g.P("func (d *DebugStreamManager[TReq, TResp]) AddStream(ctx context.Context, request *TReq, stream *connect.ServerStream[TResp], keyvals ...string) string {")
	g.P("	sessionID := generateSessionID()")
	g.P("	fmt.Printf(\"DebugStreamManager: AddStream sessionID=%s keyvals=%v\\n\", sessionID, keyvals)")
	g.P("	return sessionID")
	g.P("}")
	g.P("func (d *DebugStreamManager[TReq, TResp]) SendToStream(sessionID string, response *TResp) error {")
	g.P("	fmt.Printf(\"DebugStreamManager: SendToStream sessionID=%s\\n\", sessionID)")
	g.P("	return nil")
	g.P("}")
	g.P("func (d *DebugStreamManager[TReq, TResp]) GetContext(sessionID string) (*StreamContext[TReq, TResp], bool) {")
	g.P("	fmt.Printf(\"DebugStreamManager: GetContext sessionID=%s\\n\", sessionID)")
	g.P("	return nil, false")
	g.P("}")
	g.P("func (d *DebugStreamManager[TReq, TResp]) RemoveStream(sessionID string) {")
	g.P("	fmt.Printf(\"DebugStreamManager: RemoveStream sessionID=%s\\n\", sessionID)")
	g.P("}")
	g.P("func (d *DebugStreamManager[TReq, TResp]) HasStream(sessionID string) bool {")
	g.P("	fmt.Printf(\"DebugStreamManager: HasStream sessionID=%s\\n\", sessionID)")
	g.P("	return false")
	g.P("}")
	g.P("func (d *DebugStreamManager[TReq, TResp]) StreamCount() int {")
	g.P("	fmt.Printf(\"DebugStreamManager: StreamCount\\n\")")
	g.P("	return 0")
	g.P("}")
	g.P("func (d *DebugStreamManager[TReq, TResp]) SendToStreamsFiltered(response *TResp, filter StreamFilter[TReq, TResp]) ([]string, error) {")
	g.P("	fmt.Printf(\"DebugStreamManager: SendToStreamsFiltered\\n\")")
	g.P("	return []string{\"debug\"}, nil")
	g.P("}")
	g.P("func (d *DebugStreamManager[TReq, TResp]) SendToStreamsWithMetadata(response *TResp, key, value string) ([]string, error) {")
	g.P("	fmt.Printf(\"DebugStreamManager: SendToStreamsWithMetadata key=%s value=%s\\n\", key, value)")
	g.P("	return []string{\"debug\"}, nil")
	g.P("}")
	g.P("func (d *DebugStreamManager[TReq, TResp]) ListStreams(filter StreamFilter[TReq, TResp]) []*StreamContext[TReq, TResp] {")
	g.P("	fmt.Printf(\"DebugStreamManager: ListStreams\\n\")")
	g.P("	return nil")
	g.P("}")
	g.P()
}

func generateServiceStreamManagers(g *protogen.GeneratedFile, file *protogen.File, service *protogen.Service) {
	// Collect all streaming methods for this service
	var streamingMethods []*protogen.Method
	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() {
			streamingMethods = append(streamingMethods, method)
		}
	}

	if len(streamingMethods) == 0 {
		return
	}

	generateServiceStreamManagerInterface(g, file, service, streamingMethods)
	generateServiceStreamManager(g, file, service, streamingMethods)
}

func generateServiceStreamManagerInterface(g *protogen.GeneratedFile, file *protogen.File, service *protogen.Service, methods []*protogen.Method) {
	serviceName := string(service.Desc.Name())
	interfaceName := fmt.Sprintf("%sStreamManagerInterface", serviceName)

	g.P("// ", interfaceName, " defines the interface for ", serviceName, " stream management")
	g.P("type ", interfaceName, " interface {")

	// Generate interface methods for each streaming RPC
	for _, method := range methods {
		methodName := string(method.Desc.Name())
		requestType := method.Input.GoIdent
		responseType := method.Output.GoIdent

		g.P("	Add", methodName, "Stream(ctx context.Context, request *", requestType, ", stream *connect.ServerStream[", responseType, "], keyvals ...string) string")
		g.P("	Get", methodName, "Context(sessionID string) (*StreamContext[", requestType, ", ", responseType, "], bool)")
		g.P("	SendTo", methodName, "Stream(sessionID string, response *", responseType, ") error")
		g.P("	Remove", methodName, "Stream(sessionID string)")
		g.P("	Has", methodName, "Stream(sessionID string) bool")
		g.P("	SendTo", methodName, "Streams(response *", responseType, ") ([]string, error)")
		g.P("	SendTo", methodName, "StreamsFiltered(response *", responseType, ", key, value string) ([]string, error)")
		g.P("	List", methodName, "Streams(filter StreamFilter[", requestType, ", ", responseType, "]) []*StreamContext[", requestType, ", ", responseType, "]")
	}

	g.P("	Stats() map[string]int")
	g.P("}")
	g.P()
}

func generateServiceStreamManager(g *protogen.GeneratedFile, file *protogen.File, service *protogen.Service, methods []*protogen.Method) {
	serviceName := string(service.Desc.Name())
	managerTypeName := fmt.Sprintf("%sStreamManager", serviceName)

	g.P("// ", managerTypeName, " manages all streaming RPCs for ", serviceName)
	g.P("type ", managerTypeName, " struct {")

	// Generate a field for each streaming method
	for _, method := range methods {
		methodName := string(method.Desc.Name())
		requestType := method.Input.GoIdent
		responseType := method.Output.GoIdent
		g.P("	", methodName, " *StreamManager[", requestType, ", ", responseType, "]")
	}

	g.P("}")
	g.P()

	// Generate constructor
	g.P("func New", managerTypeName, "() *", managerTypeName, " {")
	g.P("	return &", managerTypeName, "{")
	for _, method := range methods {
		methodName := string(method.Desc.Name())
		requestType := method.Input.GoIdent
		responseType := method.Output.GoIdent
		g.P("		", methodName, ": NewStreamManager[", requestType, ", ", responseType, "](),")
	}
	g.P("	}")
	g.P("}")
	g.P()

	// Generate convenience methods for each streaming RPC
	for _, method := range methods {
		methodName := string(method.Desc.Name())
		requestType := method.Input.GoIdent
		responseType := method.Output.GoIdent

		g.P("// Add", methodName, "Stream adds a stream for the ", methodName, " RPC")
		g.P("func (m *", managerTypeName, ") Add", methodName, "Stream(ctx context.Context, request *", requestType, ", stream *connect.ServerStream[", responseType, "], keyvals ...string) string {")
		g.P("	return m.", methodName, ".AddStream(ctx, request, stream, keyvals...)")
		g.P("}")
		g.P()

		g.P("// Get", methodName, "Context retrieves the context for a ", methodName, " stream")
		g.P("func (m *", managerTypeName, ") Get", methodName, "Context(sessionID string) (*StreamContext[", requestType, ", ", responseType, "], bool) {")
		g.P("	return m.", methodName, ".GetContext(sessionID)")
		g.P("}")
		g.P()

		g.P("// SendTo", methodName, "Stream sends a response to a ", methodName, " stream")
		g.P("func (m *", managerTypeName, ") SendTo", methodName, "Stream(sessionID string, response *", responseType, ") error {")
		g.P("	return m.", methodName, ".SendToStream(sessionID, response)")
		g.P("}")
		g.P()

		g.P("// Remove", methodName, "Stream removes a ", methodName, " stream")
		g.P("func (m *", managerTypeName, ") Remove", methodName, "Stream(sessionID string) {")
		g.P("	m.", methodName, ".RemoveStream(sessionID)")
		g.P("}")
		g.P()

		g.P("// Has", methodName, "Stream checks if a ", methodName, " stream exists")
		g.P("func (m *", managerTypeName, ") Has", methodName, "Stream(sessionID string) bool {")
		g.P("	return m.", methodName, ".HasStream(sessionID)")
		g.P("}")
		g.P()

		g.P("// SendTo", methodName, "Streams sends a response to all ", methodName, " streams")
		g.P("func (m *", managerTypeName, ") SendTo", methodName, "Streams(response *", responseType, ") ([]string, error) {")
		g.P("	return m.", methodName, ".SendToStreamsFiltered(response, nil)")
		g.P("}")
		g.P()

		g.P("// SendTo", methodName, "StreamsFiltered sends a response to ", methodName, " streams matching the metadata")
		g.P("func (m *", managerTypeName, ") SendTo", methodName, "StreamsFiltered(response *", responseType, ", key, value string) ([]string, error) {")
		g.P("	return m.", methodName, ".SendToStreamsWithMetadata(response, key, value)")
		g.P("}")
		g.P()

		g.P("// List", methodName, "Streams returns all ", methodName, " streams matching the filter")
		g.P("func (m *", managerTypeName, ") List", methodName, "Streams(filter StreamFilter[", requestType, ", ", responseType, "]) []*StreamContext[", requestType, ", ", responseType, "] {")
		g.P("	return m.", methodName, ".ListStreams(filter)")
		g.P("}")
		g.P()
	}

	// Generate aggregate methods
	g.P("// Stats returns stream counts for all methods")
	g.P("func (m *", managerTypeName, ") Stats() map[string]int {")
	g.P("	stats := make(map[string]int)")
	for _, method := range methods {
		methodName := string(method.Desc.Name())
		g.P("	stats[\"", methodName, "\"] = m.", methodName, ".StreamCount()")
	}
	g.P("	return stats")
	g.P("}")
	g.P()

	// Generate NoOp version
	noOpTypeName := fmt.Sprintf("NoOp%sStreamManager", serviceName)
	g.P("// ", noOpTypeName, " is a no-op implementation for testing")
	g.P("type ", noOpTypeName, " struct {}")
	g.P()
	g.P("func New", noOpTypeName, "() *", noOpTypeName, " {")
	g.P("	return &", noOpTypeName, "{}")
	g.P("}")
	g.P()

	for _, method := range methods {
		methodName := string(method.Desc.Name())
		requestType := method.Input.GoIdent
		responseType := method.Output.GoIdent

		g.P("func (n *", noOpTypeName, ") Add", methodName, "Stream(ctx context.Context, request *", requestType, ", stream *connect.ServerStream[", responseType, "], keyvals ...string) string { return \"noop\" }")
		g.P("func (n *", noOpTypeName, ") Get", methodName, "Context(sessionID string) (*StreamContext[", requestType, ", ", responseType, "], bool) { return nil, false }")
		g.P("func (n *", noOpTypeName, ") SendTo", methodName, "Stream(sessionID string, response *", responseType, ") error { return nil }")
		g.P("func (n *", noOpTypeName, ") Remove", methodName, "Stream(sessionID string) {}")
		g.P("func (n *", noOpTypeName, ") Has", methodName, "Stream(sessionID string) bool { return false }")
		g.P("func (n *", noOpTypeName, ") SendTo", methodName, "Streams(response *", responseType, ") ([]string, error) { return nil, nil }")
		g.P("func (n *", noOpTypeName, ") SendTo", methodName, "StreamsFiltered(response *", responseType, ", key, value string) ([]string, error) { return nil, nil }")
		g.P("func (n *", noOpTypeName, ") List", methodName, "Streams(filter StreamFilter[", requestType, ", ", responseType, "]) []*StreamContext[", requestType, ", ", responseType, "] { return nil }")
	}

	g.P("func (n *", noOpTypeName, ") Stats() map[string]int { return make(map[string]int) }")
	g.P()

	// Generate Debug version
	debugTypeName := fmt.Sprintf("Debug%sStreamManager", serviceName)
	g.P("// ", debugTypeName, " logs all operations for testing")
	g.P("type ", debugTypeName, " struct {}")
	g.P()
	g.P("func New", debugTypeName, "() *", debugTypeName, " {")
	g.P("	return &", debugTypeName, "{}")
	g.P("}")
	g.P()

	for _, method := range methods {
		methodName := string(method.Desc.Name())
		requestType := method.Input.GoIdent
		responseType := method.Output.GoIdent

		g.P("func (d *", debugTypeName, ") Add", methodName, "Stream(ctx context.Context, request *", requestType, ", stream *connect.ServerStream[", responseType, "], keyvals ...string) string {")
		g.P("	sessionID := generateSessionID()")
		g.P("	fmt.Printf(\"", debugTypeName, ": Add", methodName, "Stream sessionID=%s keyvals=%v\\n\", sessionID, keyvals)")
		g.P("	return sessionID")
		g.P("}")
		g.P("func (d *", debugTypeName, ") Get", methodName, "Context(sessionID string) (*StreamContext[", requestType, ", ", responseType, "], bool) {")
		g.P("	fmt.Printf(\"", debugTypeName, ": Get", methodName, "Context sessionID=%s\\n\", sessionID)")
		g.P("	return nil, false")
		g.P("}")
		g.P("func (d *", debugTypeName, ") SendTo", methodName, "Stream(sessionID string, response *", responseType, ") error {")
		g.P("	fmt.Printf(\"", debugTypeName, ": SendTo", methodName, "Stream sessionID=%s\\n\", sessionID)")
		g.P("	return nil")
		g.P("}")
		g.P("func (d *", debugTypeName, ") Remove", methodName, "Stream(sessionID string) {")
		g.P("	fmt.Printf(\"", debugTypeName, ": Remove", methodName, "Stream sessionID=%s\\n\", sessionID)")
		g.P("}")
		g.P("func (d *", debugTypeName, ") Has", methodName, "Stream(sessionID string) bool {")
		g.P("	fmt.Printf(\"", debugTypeName, ": Has", methodName, "Stream sessionID=%s\\n\", sessionID)")
		g.P("	return false")
		g.P("}")
		g.P("func (d *", debugTypeName, ") SendTo", methodName, "Streams(response *", responseType, ") ([]string, error) {")
		g.P("	fmt.Printf(\"", debugTypeName, ": SendTo", methodName, "Streams\\n\")")
		g.P("	return []string{\"debug\"}, nil")
		g.P("}")
		g.P("func (d *", debugTypeName, ") SendTo", methodName, "StreamsFiltered(response *", responseType, ", key, value string) ([]string, error) {")
		g.P("	fmt.Printf(\"", debugTypeName, ": SendTo", methodName, "StreamsFiltered key=%s value=%s\\n\", key, value)")
		g.P("	return []string{\"debug\"}, nil")
		g.P("}")
		g.P("func (d *", debugTypeName, ") List", methodName, "Streams(filter StreamFilter[", requestType, ", ", responseType, "]) []*StreamContext[", requestType, ", ", responseType, "] {")
		g.P("	fmt.Printf(\"", debugTypeName, ": List", methodName, "Streams\\n\")")
		g.P("	return nil")
		g.P("}")
	}

	g.P("func (d *", debugTypeName, ") Stats() map[string]int {")
	g.P("	fmt.Printf(\"", debugTypeName, ": Stats\\n\")")
	g.P("	return make(map[string]int)")
	g.P("}")
	g.P()
}
